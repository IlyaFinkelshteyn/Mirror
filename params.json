{
  "name": "Mirror",
  "tagline": "",
  "body": "ï»¿## Synopsis\r\n\r\nSimplifies C# reflection code.\r\n\r\n## Code Example\r\n\r\n### Describing the target\r\n\r\nTo access or invoke a private method that is defined on a `type` or an `object` client code needs to specify the target correctly.\r\nTargets' members can be either static or instance.\r\nNotice that `constructors` must be accessed through a **static** target since no **instance target** is available yet:\r\n\r\n```cs\r\nclass MyClass {\r\n  private string name;\r\n  private MyClass() { this.name = \"Name is not set\"; }\r\n  private MyClass(string name) { this.name = name; }\r\n}\r\n\r\nMyClass targetObject = ...;\r\n\r\nvar staticTarget = Use.Target<MyClass>();\r\n// staticTarget can now be used to call constructor or\r\n// call or access static members\r\n\r\nvar instanceTarget = Use.Target(targetObject)\r\n// instanceTarget can now be used to call or access targetObject's members\r\n```\r\n\r\n### Creating an instance of an object\r\n\r\n```cs\r\n// Creates object by calling it's default constructor\r\nMyClass newInstance = Use.Target<MyClass>().ToCreateInstance();\r\n\r\n// Creates object by calling it's best matching parameterized constructor\r\nMyClass newInstance = Use.Target<MyClass>().ToCreateInstance(\"Alice\");\r\n```\r\n\r\n### Working with instance members\r\n\r\n```cs\r\nclass MyClass {\r\n  private string name;\r\n  private string Name { get { return name; } set { name = value } }\r\n  private void SetName(string newName) { name = newName; }\r\n  private string GetName() { return name; }\r\n}\r\nMyClass target = new MyClass();\r\n\r\n// Field/Property access code looks similar\r\nUse.Target(target).ToSet(\"name\").Value(\"Bob\")\r\nUse.Target(target).ToSet(\"Name\").Value(\"Chris\")\r\nstring nameFromField = Use.Target(target).ToGet<string>(\"name\");\r\nstring nameFromProperty = Use.Target(target).ToGet<string>(\"Name\");\r\n\r\n// Method access\r\nUse.Target(target).ToCall(\"SetName\", \"David\");\r\nstring nameFromMethod = Use.Target(target).ToCall<string>(\"GetName\");\r\n```\r\n\r\n### Working with static members\r\n\r\n```cs\r\nstatic class MyClass {\r\n  private static string name;\r\n  private static string Name { get { return name; } set { name = value } }\r\n  private static void SetName(string newName) { name = newName; }\r\n  private static string GetName() { return name; }\r\n}\r\n\r\nUse.Target<MyClass>().ToSet(\"name\").Value(\"Bob\")\r\nstring nameFromStaticField = Use.Target<MyClass>().ToGet<string>(\"name\");\r\n\r\nUse.Target<MyClass>().ToSet(\"Name\").Value(\"Chris\")\r\nstring nameFromStaticProperty = Use.Target<MyClass>().ToGet<string>(\"Name\");\r\n\r\nUse.Target<MyClass>().ToCall(\"SetName\", \"David\");\r\nstring nameFromStaticMethod = Use.Target<MyClass>().ToCall<string>(\"GetName\");\r\n```\r\n\r\n## Motivation\r\n\r\nSyntax sugar is syntax sugar: it's not a necessary thing per se but it can improve code quality.\r\nReflection should be your last resort tool when used in production code:\r\ntypes very often limit constructor and other members' accessibility level on purpose.\r\n\r\nIn your tests, however, it may be okay to have slightly sloppier code.\r\nFor example, you may want to build a dummy/fake object and for some reason mocking tools like NSubstitute can't do it.\r\n\r\n## Installation\r\n\r\nMirror is a available in a form of a NuGet package.\r\nFollow regular installation process to bring it to your project.\r\nhttps://www.nuget.org/packages/Mirror/\r\n\r\n## Tests\r\n\r\nUnit tests are available in Mirror.Tests project.\r\n\r\n## License\r\n\r\nThe code is distributed under the MIT license.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}