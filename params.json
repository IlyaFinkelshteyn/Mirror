{
  "name": "Mirror",
  "tagline": "Syntax-honeyed .NET reflection",
  "body": "## Synopsis\r\n\r\nSimplifies C# reflection code.\r\n\r\n## Status\r\n| | |\r\n| --- | --- |\r\n| NuGet (stable) | [![NuGet](https://img.shields.io/nuget/v/Mirror.svg)](https://www.nuget.org/packages/Mirror/) [![NuGet](https://img.shields.io/nuget/vpre/Mirror.svg)](https://www.nuget.org/packages/Mirror/) |\r\n| MyGet (latest) | [![MyGet CI](https://img.shields.io/myget/another-guy/v/Mirror.svg)](https://www.myget.org/feed/another-guy/package/nuget/Mirror) [![MyGet CI](https://img.shields.io/myget/another-guy/vpre/Mirror.svg)](https://www.myget.org/feed/another-guy/package/nuget/Mirror) |\r\n| Build| [![Build status](https://ci.appveyor.com/api/projects/status/as29kthpwxftaiy6?svg=true)](https://ci.appveyor.com/project/another-guy/mirror) |\r\n| Issues and pull requests | [![GitHub issues](https://img.shields.io/github/issues/another-guy/mirror.svg?maxAge=2592000)](https://github.com/another-guy/Mirror/issues) |\r\n\r\n## Code Example\r\n\r\n### Describing the target\r\n\r\nTo access or invoke a private method that is defined on a `type` or an `object` client code needs to specify the target correctly.\r\nTargets' members can be either static or instance.\r\nNotice that `constructors` must be accessed through a **static** target since no **instance target** is available yet:\r\n\r\n```cs\r\nclass MyClass {\r\n  private string name;\r\n  private MyClass() { this.name = \"Name is not set\"; }\r\n  private MyClass(string name) { this.name = name; }\r\n}\r\n\r\nMyClass targetObject = ...;\r\n\r\nvar staticTarget = Use.Target<MyClass>();\r\n// staticTarget can now be used to call constructor or\r\n// call or access static members\r\n\r\nvar instanceTarget = Use.Target(targetObject)\r\n// instanceTarget can now be used to call or access targetObject's members\r\n```\r\n\r\n### Creating an instance of an object\r\n\r\n```cs\r\n// Creates object by calling its default constructor\r\nMyClass newInstance = Use.Target<MyClass>().ToCreateInstance();\r\n\r\n// Creates object by calling its best matching parameterized constructor\r\nMyClass newInstance = Use.Target<MyClass>().ToCreateInstance(\"Alice\");\r\n```\r\n\r\n### Working with instance members\r\n\r\n```cs\r\nclass MyClass {\r\n  private string name;\r\n  private string Name { get { return name; } set { name = value } }\r\n  private void SetName(string newName) { name = newName; }\r\n  private string GetName() { return name; }\r\n}\r\nMyClass target = new MyClass();\r\n\r\n// Field/Property access code looks similar\r\nUse.Target(target).ToSet(\"name\").Value(\"Bob\")\r\nUse.Target(target).ToSet(\"Name\").Value(\"Chris\")\r\nstring nameFromField = Use.Target(target).ToGet<string>(\"name\");\r\nstring nameFromProperty = Use.Target(target).ToGet<string>(\"Name\");\r\n\r\n// Method access\r\nUse.Target(target).ToCall(\"SetName\", \"David\");\r\nstring nameFromMethod = Use.Target(target).ToCall<string>(\"GetName\");\r\n```\r\n\r\n### Working with static members\r\n\r\n```cs\r\nstatic class MyClass {\r\n  private static string name;\r\n  private static string Name { get { return name; } set { name = value } }\r\n  private static void SetName(string newName) { name = newName; }\r\n  private static string GetName() { return name; }\r\n}\r\n\r\nUse.Target<MyClass>().ToSet(\"name\").Value(\"Bob\")\r\nstring nameFromStaticField = Use.Target<MyClass>().ToGet<string>(\"name\");\r\n\r\nUse.Target<MyClass>().ToSet(\"Name\").Value(\"Chris\")\r\nstring nameFromStaticProperty = Use.Target<MyClass>().ToGet<string>(\"Name\");\r\n\r\nUse.Target<MyClass>().ToCall(\"SetName\", \"David\");\r\nstring nameFromStaticMethod = Use.Target<MyClass>().ToCall<string>(\"GetName\");\r\n```\r\n\r\n## Motivation\r\n\r\nSyntax sugar is syntax sugar: it's not a necessary thing per se but it can improve code quality.\r\nReflection should be your last resort tool when used in production code:\r\ntypes very often limit constructor and other members' accessibility level on purpose.\r\n\r\nIn your tests, however, it may be okay to have slightly sloppier code.\r\nFor example, you may want to build a dummy/fake object and for some reason mocking tools like NSubstitute can't do it.\r\n\r\n## Installation\r\n\r\nMirror is a available in a form of a NuGet package.\r\nFollow regular installation process to bring it to your project.\r\nhttps://www.nuget.org/packages/Mirror/\r\n\r\n## Tests\r\n\r\nUnit tests are available in Mirror.Tests project.\r\n\r\n## License\r\n\r\nThe code is distributed under the MIT license.\r\n\r\n## Reporting an Issue\r\n\r\nReporting an issue, proposing a feature, or asking a question are all great ways to improve software quality.\r\n\r\nHere are a few important things that package contributors will expect to see in a new born GitHub issue:\r\n* the relevant version of the package;\r\n* the steps to reproduce;\r\n* the expected result;\r\n* the observed result;\r\n* some code samples illustrating current inconveniences and/or proposed improvements.\r\n\r\n## Contributing\r\n\r\nContribution is the best way to improve any project!\r\n\r\n1. Fork it!\r\n2. Create your feature branch (```git checkout -b my-new-feature```).\r\n3. Commit your changes (```git commit -am 'Added some feature'```)\r\n4. Push to the branch (```git push origin my-new-feature```)\r\n5. Create new Pull Request\r\n\r\n...or follow steps described in a nice [fork guide](http://kbroman.org/github_tutorial/pages/fork.html) by Karl Broman\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}